// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

// KeeperCompatible.sol imports the functions from both ./KeeperBase.sol and
// ./interfaces/KeeperCompatibleInterface.sol
import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract Cthulgotchis is ERC721, Ownable, ERC721Enumerable, ERC721URIStorage, ERC721Burnable, KeeperCompatibleInterface {
    using Counters for Counters.Counter;

    Counters.Counter private _tokenIdCounter;

    mapping(uint256 => uint256) public lastTimeFeed;
    mapping(uint256 => uint256) public mintDate;

    address keeperAddress;

    // uint256 burnInterval = 60 * 60 * 24; // (seconds) = one day. 
    uint256 burnInterval = 60 * 2;

    // Keeper states
    // The Keep tries checkUpKeep on every block. (12seg in ETH)
    // uint interval; // This is just an optional variable to calculate or restrict action.
    // uint lastTimeStamp; // This will be the last time that we executed the Keeper Action.

    // Metadata information for each stage of the NFT on IPFS.
    string[] IpfsUri = [
        "https://gateway.pinata.cloud/ipfs/QmTpKCi9JhaqC4hBT4xPEn155nyq5myfSLXhRZDWu9LRVg/cthulgotchi-json-0.json",
        "https://gateway.pinata.cloud/ipfs/QmTpKCi9JhaqC4hBT4xPEn155nyq5myfSLXhRZDWu9LRVg/cthulgotchi-json-1.json",
        "https://gateway.pinata.cloud/ipfs/QmTpKCi9JhaqC4hBT4xPEn155nyq5myfSLXhRZDWu9LRVg/cthulgotchi-json-2.json",
        "https://gateway.pinata.cloud/ipfs/QmTpKCi9JhaqC4hBT4xPEn155nyq5myfSLXhRZDWu9LRVg/cthulgotchi-json-3.json",
        "https://gateway.pinata.cloud/ipfs/QmTpKCi9JhaqC4hBT4xPEn155nyq5myfSLXhRZDWu9LRVg/cthulgotchi-json-4.json"
    ];

    event Feed(
        address indexed owner,
        uint256 indexed tokenId,
        uint256 indexed timestamp
    );

    event Evolve(
        address indexed owner,
        uint256 indexed tokenId,
        uint256 indexed evolution
    );

    event Burned(
        address indexed exOwner,
        uint256 indexed exTokenId,
        uint256 stage,
        uint256 indexed age
    );

    modifier onlyNFTOwner(uint256 _tokenId) {
        require(
            msg.sender == ownerOf(_tokenId),
            "Only the NFT owner is able to execute this function."
        );
        _;
    }

    constructor(/*uint _interval*/) ERC721("Cthulgotchis", "CGC") {
        // interval = _interval;
        // lastTimeStamp = block.timestamp;
    }

    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        // upkeepNeeded = (block.timestamp - lastTimeFeed) > interval;
        upkeepNeeded = getAllHungryIds().length > 0;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        // if ((block.timestamp - lastTimeStamp) > interval ) {
        //     lastTimeStamp = block.timestamp;
        //     tryEvolvingNFT(0);
        // }
        uint256[] memory burnIds = getAllHungryIds();
        for (uint256 i = 0; i < burnIds.length; i++ ){
            burn(burnIds[i]);
            // address exOwner, uint256 exTokenId, uint256 stage, uint256 age
            emit Burned(ownerOf(burnIds[i]), burnIds[i], getCurrentStage(burnIds[i]), block.timestamp - mintDate[burnIds[i]]);
        }

        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }


    function safeMint(address to) public {
        // everyone can mint, with a maximun of 3.
        require(balanceOf(to) < 3, "Max 3 NFT's per address");
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, IpfsUri[0]);
        // set as feeded at the minting timestamp
        mintDate[tokenId] = block.timestamp;
        lastTimeFeed[tokenId] = block.timestamp;
        approve(owner(), tokenId);
    }

    function feedNFT(uint256 _tokenId) public onlyNFTOwner(_tokenId) {
        lastTimeFeed[_tokenId] = block.timestamp;
        emit Feed(msg.sender, _tokenId, block.timestamp);

        // If the time for evolving has come, evolve!
        // tryEvolvingNFT(_tokenId);
    }

    function tryEvolvingNFT(uint256 _tokenId) private {
        uint256 age = block.timestamp - mintDate[_tokenId];
        uint256 currentStage = getCurrentStage(_tokenId);

        if (currentStage >= 4) {return;} // cannot evolve from stage 4
        if (currentStage == 0 && age < 4 minutes) {return;}
        if (currentStage == 1 && age < 9 minutes) {return;}
        if (currentStage == 2 && age < 14 minutes) {return;}
        if (currentStage == 3 && age < 19 minutes) {return;}

        // Get the current stage of the NFT and add 1
        uint256 newVal = currentStage + 1;
        // store the new URI
        string memory newUri = IpfsUri[newVal];
        // Update the URI
        _setTokenURI(_tokenId, newUri);
        emit Evolve(msg.sender, _tokenId, newVal);
    }

     // determine the stage of the cthulgotchie growth
    function getCurrentStage(uint256 _tokenId) public view returns (uint256) {
        string memory _uri = tokenURI(_tokenId);
        if (compareStrings(_uri, IpfsUri[0])) {return 0;} // Egg
        if (compareStrings(_uri, IpfsUri[1])) {return 1;} // Baby
        if (compareStrings(_uri, IpfsUri[2])) {return 2;} // Young
        if (compareStrings(_uri, IpfsUri[3])) {return 3;} // Adult
        return 4; // King
    }

    function setKeeperAddress(address _keeperAddress) public onlyOwner{
        keeperAddress = _keeperAddress;
    }

    function compareStrings(string memory a, string memory b)
        public
        pure
        returns (bool)
    {
        return (keccak256(abi.encodePacked((a))) ==
            keccak256(abi.encodePacked((b))));
    }

    function getAllTokenIds() public view returns(uint256[] memory ) {

        uint256 totalSupply = totalSupply();
        uint256[] memory tokenIds = new uint256[](totalSupply);

        for (uint256 i = 0; i < totalSupply; i++){
            tokenIds[i] = tokenByIndex(i);
        }
        return tokenIds;
    }

    function getAllHungryIds() public view returns (uint256[] memory){
        
        uint256[] memory allTokenIds = getAllTokenIds();
        // filter to get which ones has to be burned.
        uint256 hungryCounter;
        for ( uint256 i = 0; i < allTokenIds.length; i++ ){
            if (block.timestamp - lastTimeFeed[allTokenIds[i]] >= burnInterval ){
                hungryCounter++;
            }
        }   
        
        uint256[] memory allHungryIds = new uint256[](hungryCounter);
        for ( uint256 i = 0; i < allTokenIds.length; i++ ){
            if (block.timestamp - lastTimeFeed[allTokenIds[i]] >= burnInterval ){
                allHungryIds[i] = allTokenIds[i];
            }
        } 
        return allHungryIds;
    }

    // The following functions are overrides required by Solidity.

    function _beforeTokenTransfer(address from, address to, uint256 tokenId)
        internal
        override(ERC721, ERC721Enumerable)
    {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
